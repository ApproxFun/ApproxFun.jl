{
    "docs": [
        {
            "location": "/", 
            "text": "ApproxFun.jl Documentation\n\n\n\n\nDomains\n\n\n#\n\n\nApproxFun.Interval\n \n \nType\n.\n\n\nInterval(a,b)\n\n\n\n\nrepresents an interval from \na\n to \nb\n.  In the case where \na\n and \nb\n are complex or 2-dimensional, it represents the line segment between \na\n and \nb\n.\n\n\nsource\n\n\n\n\nConstructing a Fun\n\n\n#\n\n\nApproxFun.Fun\n \n \nType\n.\n\n\nFun(coefficients,space)\n\n\n\n\nreturns a Fun with coefficients in the space\n\n\nsource\n\n\n\n\nAccessing information about a Fun\n\n\n#\n\n\nApproxFun.domain\n \n \nFunction\n.\n\n\ndomain(::Fun)\n\n\n\n\nreturns the domain that a \nFun\n is defined on\n\n\nsource\n\n\n#\n\n\nApproxFun.coefficients\n \n \nFunction\n.\n\n\ncoefficients(fun,space)\n\n\n\n\nreturns the coefficients of a fun in a possibly different space\n\n\nsource\n\n\n#\n\n\nApproxFun.extrapolate\n \n \nFunction\n.\n\n\nextrapolate(fun,x)\n\n\n\n\nreturns an extrapolation of \nfun\n from its domain to \nx\n.\n\n\nsource\n\n\n#\n\n\nApproxFun.ncoefficients\n \n \nFunction\n.\n\n\nncoefficients(fun) -\n Integer\n\n\n\n\nreturns the number of coefficients of a fun\n\n\nsource\n\n\n#\n\n\nApproxFun.points\n \n \nFunction\n.\n\n\npoints(fun)\n\n\n\n\nreturns a grid of points that the fun can be transformed into values and back\n\n\nsource\n\n\n#\n\n\nApproxFun.space\n \n \nFunction\n.\n\n\nspace(fun)\n\n\n\n\nreturns the space of \nfun\n\n\nsource\n\n\n#\n\n\nBase.values\n \n \nFunction\n.\n\n\nvalues(collection)\n\n\n\n\nReturn an iterator over all values in a collection. \ncollect(values(d))\n returns an array of values.\n\n\nsource\n\n\n\n\nModify a Fun\n\n\n#\n\n\nApproxFun.reverseorientation\n \n \nFunction\n.\n\n\nreverseorientation(fun)\n\n\n\n\nreturn \nfun\n on a reversed orientated contour\n\n\nsource\n\n\n#\n\n\nApproxFun.setdomain\n \n \nFunction\n.\n\n\nsetdomain(fun,domain)\n\n\n\n\nreturns \nfun\n projected onto \ndomain\n\n\nsource\n\n\n#\n\n\nBase.chop\n \n \nFunction\n.\n\n\nchop(string)\n\n\n\n\nRemove the last character from a string.\n\n\nsource\n\n\n\n\nOperators\n\n\n#\n\n\nApproxFun.Operator\n \n \nType\n.\n\n\nOperator{T}\n\n\n\n\nis an abstract type to represent linear operators between spaces.\n\n\nsource\n\n\n#\n\n\nApproxFun.linsolve\n \n \nFunction\n.\n\n\nlinsolve(A,b;tolerance=tol,maxlength=n)\n\n\n\n\nsolves a linear equation, usually differential equation, where \nA\n is an operator or array of operators and \nb\n is a \nFun\n or array of funs.  The result \nu\n will approximately satisfy \nA*u = b\n.\n\n\nsource\n\n\n#\n\n\nBase.LinAlg.qrfact\n \n \nMethod\n.\n\n\nqrfact(A::Operator)\n\n\n\n\nreturns a cached QR factorization of the Operator \nA\n.  The result \nQR\n enables solving of linear equations: if \nu=QR\\b\n, then \nu\n approximately satisfies \nA*u = b\n.\n\n\nsource\n\n\n#\n\n\nApproxFun.cache\n \n \nMethod\n.\n\n\ncache(operator)\n\n\n\n\nCaches the entries of an operator, to speed up multiplying a Fun by the operator.\n\n\nsource", 
            "title": "Home"
        }, 
        {
            "location": "/#approxfunjl-documentation", 
            "text": "", 
            "title": "ApproxFun.jl Documentation"
        }, 
        {
            "location": "/#domains", 
            "text": "#  ApproxFun.Interval     Type .  Interval(a,b)  represents an interval from  a  to  b .  In the case where  a  and  b  are complex or 2-dimensional, it represents the line segment between  a  and  b .  source", 
            "title": "Domains"
        }, 
        {
            "location": "/#constructing-a-fun", 
            "text": "#  ApproxFun.Fun     Type .  Fun(coefficients,space)  returns a Fun with coefficients in the space  source", 
            "title": "Constructing a Fun"
        }, 
        {
            "location": "/#accessing-information-about-a-fun", 
            "text": "#  ApproxFun.domain     Function .  domain(::Fun)  returns the domain that a  Fun  is defined on  source  #  ApproxFun.coefficients     Function .  coefficients(fun,space)  returns the coefficients of a fun in a possibly different space  source  #  ApproxFun.extrapolate     Function .  extrapolate(fun,x)  returns an extrapolation of  fun  from its domain to  x .  source  #  ApproxFun.ncoefficients     Function .  ncoefficients(fun) -  Integer  returns the number of coefficients of a fun  source  #  ApproxFun.points     Function .  points(fun)  returns a grid of points that the fun can be transformed into values and back  source  #  ApproxFun.space     Function .  space(fun)  returns the space of  fun  source  #  Base.values     Function .  values(collection)  Return an iterator over all values in a collection.  collect(values(d))  returns an array of values.  source", 
            "title": "Accessing information about a Fun"
        }, 
        {
            "location": "/#modify-a-fun", 
            "text": "#  ApproxFun.reverseorientation     Function .  reverseorientation(fun)  return  fun  on a reversed orientated contour  source  #  ApproxFun.setdomain     Function .  setdomain(fun,domain)  returns  fun  projected onto  domain  source  #  Base.chop     Function .  chop(string)  Remove the last character from a string.  source", 
            "title": "Modify a Fun"
        }, 
        {
            "location": "/#operators", 
            "text": "#  ApproxFun.Operator     Type .  Operator{T}  is an abstract type to represent linear operators between spaces.  source  #  ApproxFun.linsolve     Function .  linsolve(A,b;tolerance=tol,maxlength=n)  solves a linear equation, usually differential equation, where  A  is an operator or array of operators and  b  is a  Fun  or array of funs.  The result  u  will approximately satisfy  A*u = b .  source  #  Base.LinAlg.qrfact     Method .  qrfact(A::Operator)  returns a cached QR factorization of the Operator  A .  The result  QR  enables solving of linear equations: if  u=QR\\b , then  u  approximately satisfies  A*u = b .  source  #  ApproxFun.cache     Method .  cache(operator)  Caches the entries of an operator, to speed up multiplying a Fun by the operator.  source", 
            "title": "Operators"
        }, 
        {
            "location": "/faq/", 
            "text": "Frequently Asked Questions\n\n\n\n\nApproximating functions\n\n\n\n\nHow do I interpolate a function at a specified grid?\n\n\nIn the case where the grid is specified by \npoints(space,n)\n, you can apply the default transform to data:\n\n\nS = Chebyshev([1,2])  \np = points(S,20) # the default grid\nv = exp.(p)      # values at the default grid\nf = Fun(ApproxFun.transform(S,vals),S)\n\n\n\n\nApproxFun has no inbuilt support for interpolating functions at other sets of points, but this can be accomplished manually by evaluating the basis at the set of points and using \\:\n\n\nS = Chebyshev([1,2])  \nn = 50\np = linspace(1,2,n)  # a non-default grid\nv = exp.(p)           # values at the non-default grid\n# Create a Vandermonde matrix by evaluating the basis at the grid\nV = Array(Float64,n,n)\nfor k = 1:n\n    V[:,k] = Fun([zeros(k-1);1],S)(p)\nend\nf = Fun(V\\v,S)   \n\n\n\n\nNote that an evenly spaced grid suffers from instability for large \nn\n.  The easiest way around this is to use least squares with more points than coefficients, instead of interpolation:\n\n\nS = Chebyshev([1,2])  \nn = 100; m = 50\np = linspace(1,2,n)  # a non-default grid\nv = exp.(p)           # values at the non-default grid\n# Create a Vandermonde matrix by evaluating the basis at the grid\nV = Array(Float64,n,m)\nfor k = 1:m\n    V[:,k] = Fun([zeros(k-1);1],S)(p)\nend\nf = Fun(V\\v,S)", 
            "title": "FAQ"
        }, 
        {
            "location": "/faq/#frequently-asked-questions", 
            "text": "", 
            "title": "Frequently Asked Questions"
        }, 
        {
            "location": "/faq/#approximating-functions", 
            "text": "", 
            "title": "Approximating functions"
        }, 
        {
            "location": "/faq/#how-do-i-interpolate-a-function-at-a-specified-grid", 
            "text": "In the case where the grid is specified by  points(space,n) , you can apply the default transform to data:  S = Chebyshev([1,2])  \np = points(S,20) # the default grid\nv = exp.(p)      # values at the default grid\nf = Fun(ApproxFun.transform(S,vals),S)  ApproxFun has no inbuilt support for interpolating functions at other sets of points, but this can be accomplished manually by evaluating the basis at the set of points and using \\:  S = Chebyshev([1,2])  \nn = 50\np = linspace(1,2,n)  # a non-default grid\nv = exp.(p)           # values at the non-default grid\n# Create a Vandermonde matrix by evaluating the basis at the grid\nV = Array(Float64,n,n)\nfor k = 1:n\n    V[:,k] = Fun([zeros(k-1);1],S)(p)\nend\nf = Fun(V\\v,S)     Note that an evenly spaced grid suffers from instability for large  n .  The easiest way around this is to use least squares with more points than coefficients, instead of interpolation:  S = Chebyshev([1,2])  \nn = 100; m = 50\np = linspace(1,2,n)  # a non-default grid\nv = exp.(p)           # values at the non-default grid\n# Create a Vandermonde matrix by evaluating the basis at the grid\nV = Array(Float64,n,m)\nfor k = 1:m\n    V[:,k] = Fun([zeros(k-1);1],S)(p)\nend\nf = Fun(V\\v,S)", 
            "title": "How do I interpolate a function at a specified grid?"
        }
    ]
}