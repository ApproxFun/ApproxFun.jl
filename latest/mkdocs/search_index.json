{
    "docs": [
        {
            "location": "/", 
            "text": "ApproxFun.jl Documentation\n\n\n\n\nDomains\n\n\n#\n\n\nApproxFun.Arc\n \n \nType\n.\n\n\nArc(c,r,(\u03b8\u2081,\u03b8\u2082))\n\n\n\n\nrepresents the arc centred at \nc\n with radius \nr\n from angle \n\u03b8\u2081\n to \n\u03b8\u2082\n. \n\n\nsource\n\n\n#\n\n\nApproxFun.Circle\n \n \nType\n.\n\n\nCircle(c,r,o)\n\n\n\n\nrepresents the circle centred at \nc\n with radius \nr\n which is positively (\no=true\n) or negatively (\no=false\n) oriented.\n\n\nsource\n\n\n#\n\n\nApproxFun.Curve\n \n \nConstant\n.\n\n\nCurve\n Represents a domain defined by the image of a Fun.  Example usage would be\n\n\nx=Fun([1,2])\nCurve(exp(im*x))  # represents an arc\n\n\n\n\nsource\n\n\n#\n\n\nApproxFun.Disk\n \n \nType\n.\n\n\nDisk(c,r)\n\n\n\n\nrepresents the disk centred at \nc\n with radius \nr\n.\n\n\nsource\n\n\n#\n\n\nApproxFun.Interval\n \n \nType\n.\n\n\nInterval(a,b)\n\n\n\n\nrepresents an interval from \na\n to \nb\n.  In the case where \na\n and \nb\n are complex or 2-dimensional, it represents the line segment between \na\n and \nb\n.\n\n\nsource\n\n\n#\n\n\nApproxFun.Line\n \n \nType\n.\n\n\nLine{a}(c)\n\n\n\n\nrepresents the line at angle \na\n in the complex plane, centred at \nc\n.\n\n\nsource\n\n\n#\n\n\nApproxFun.PeriodicInterval\n \n \nType\n.\n\n\nPeriodicInterval(a,b)\n\n\n\n\nrepresents a periodic interval from \na\n to \nb\n, that is, the point \nb\n is identified with \na\n.\n\n\nsource\n\n\n#\n\n\nApproxFun.ProductDomain\n \n \nType\n.\n\n\nProductDomain((d1,d2))\n\n\n\n\nrepresents the product of two domains, the set \n{(x,y) : x \u2208 d1 \n y \u2208 d2}\n.\n\n\nMultiplication of domains is overrident to return a \nProductDomain\n. For example, the following represents the rectangle \n1 \u2264\u00a0x \u2264\u00a02 \n 3 \u2264\u00a0y \u2264\u00a04\n:\n\n\nInterval(1,2)*(3,4)\n\n\n\n\nsource\n\n\n#\n\n\nApproxFun.Ray\n \n \nType\n.\n\n\nRay{a}(c,o)\n\n\n\n\nrepresents a ray at angle \na\n starting at \nc\n, with orientation out to infinity (\no = true\n) or back from infinity (\no = false\n).\n\n\nsource\n\n\n#\n\n\nApproxFun.UnionDomain\n \n \nType\n.\n\n\nUnionDomain((d1,d2,\u2026,dn))\n\n\n\n\nrepresents a union of multiple subdomains: \n{x : x \u2208 d1 || \u2026 || x \u2208 dn}\n.\n\n\nsource\n\n\n#\n\n\nApproxFun.\u2202\n \n \nFunction\n.\n\n\n\u2202(domain)\n\n\n\n\nreturns the boundary of \ndomain\n.  For example, the boundary of a \nDisk()\n is a \nCircle()\n, and the boundary of \nInterval()^2\n is a piecewise interval that sketches the boundary of a rectangle.\n\n\nsource\n\n\n\n\nConstructing a Fun\n\n\n#\n\n\nApproxFun.Fun\n \n \nType\n.\n\n\nFun(coefficients,space)\n\n\n\n\nreturns a Fun with coefficients in the space\n\n\nsource\n\n\n\n\nAccessing information about a Fun\n\n\n#\n\n\nApproxFun.domain\n \n \nFunction\n.\n\n\ndomain(::Fun)\n\n\n\n\nreturns the domain that a \nFun\n is defined on\n\n\nsource\n\n\n#\n\n\nApproxFun.coefficients\n \n \nFunction\n.\n\n\ncoefficients(fun,space)\n\n\n\n\nreturns the coefficients of a fun in a possibly different space\n\n\nsource\n\n\n#\n\n\nApproxFun.extrapolate\n \n \nFunction\n.\n\n\nextrapolate(fun,x)\n\n\n\n\nreturns an extrapolation of \nfun\n from its domain to \nx\n.\n\n\nsource\n\n\n#\n\n\nApproxFun.ncoefficients\n \n \nFunction\n.\n\n\nncoefficients(fun) -\n Integer\n\n\n\n\nreturns the number of coefficients of a fun\n\n\nsource\n\n\n#\n\n\nApproxFun.points\n \n \nFunction\n.\n\n\npoints(fun)\n\n\n\n\nreturns a grid of points that the fun can be transformed into values and back\n\n\nsource\n\n\n#\n\n\nApproxFun.space\n \n \nFunction\n.\n\n\nspace(fun)\n\n\n\n\nreturns the space of \nfun\n\n\nsource\n\n\n#\n\n\nBase.values\n \n \nFunction\n.\n\n\nvalues(collection)\n\n\n\n\nReturn an iterator over all values in a collection. \ncollect(values(d))\n returns an array of values.\n\n\nsource\n\n\n\n\nModify a Fun\n\n\n#\n\n\nApproxFun.reverseorientation\n \n \nFunction\n.\n\n\nreverseorientation(fun)\n\n\n\n\nreturn \nfun\n on a reversed orientated contour\n\n\nsource\n\n\n#\n\n\nApproxFun.setdomain\n \n \nFunction\n.\n\n\nsetdomain(fun,domain)\n\n\n\n\nreturns \nfun\n projected onto \ndomain\n\n\nsource\n\n\n#\n\n\nBase.chop\n \n \nFunction\n.\n\n\nchop(string)\n\n\n\n\nRemove the last character from a string.\n\n\nsource\n\n\n\n\nOperators\n\n\n#\n\n\nApproxFun.Operator\n \n \nType\n.\n\n\nOperator{T}\n\n\n\n\nis an abstract type to represent linear operators between spaces.\n\n\nsource\n\n\n#\n\n\nApproxFun.linsolve\n \n \nFunction\n.\n\n\nlinsolve(A,b;tolerance=tol,maxlength=n)\n\n\n\n\nsolves a linear equation, usually differential equation, where \nA\n is an operator or array of operators and \nb\n is a \nFun\n or array of funs.  The result \nu\n will approximately satisfy \nA*u = b\n.\n\n\nsource\n\n\n#\n\n\nBase.LinAlg.qrfact\n \n \nMethod\n.\n\n\nqrfact(A::Operator)\n\n\n\n\nreturns a cached QR factorization of the Operator \nA\n.  The result \nQR\n enables solving of linear equations: if \nu=QR\\b\n, then \nu\n approximately satisfies \nA*u = b\n.\n\n\nsource\n\n\n#\n\n\nApproxFun.cache\n \n \nMethod\n.\n\n\ncache(operator)\n\n\n\n\nCaches the entries of an operator, to speed up multiplying a Fun by the operator.\n\n\nsource", 
            "title": "Home"
        }, 
        {
            "location": "/#approxfunjl-documentation", 
            "text": "", 
            "title": "ApproxFun.jl Documentation"
        }, 
        {
            "location": "/#domains", 
            "text": "#  ApproxFun.Arc     Type .  Arc(c,r,(\u03b8\u2081,\u03b8\u2082))  represents the arc centred at  c  with radius  r  from angle  \u03b8\u2081  to  \u03b8\u2082 .   source  #  ApproxFun.Circle     Type .  Circle(c,r,o)  represents the circle centred at  c  with radius  r  which is positively ( o=true ) or negatively ( o=false ) oriented.  source  #  ApproxFun.Curve     Constant .  Curve  Represents a domain defined by the image of a Fun.  Example usage would be  x=Fun([1,2])\nCurve(exp(im*x))  # represents an arc  source  #  ApproxFun.Disk     Type .  Disk(c,r)  represents the disk centred at  c  with radius  r .  source  #  ApproxFun.Interval     Type .  Interval(a,b)  represents an interval from  a  to  b .  In the case where  a  and  b  are complex or 2-dimensional, it represents the line segment between  a  and  b .  source  #  ApproxFun.Line     Type .  Line{a}(c)  represents the line at angle  a  in the complex plane, centred at  c .  source  #  ApproxFun.PeriodicInterval     Type .  PeriodicInterval(a,b)  represents a periodic interval from  a  to  b , that is, the point  b  is identified with  a .  source  #  ApproxFun.ProductDomain     Type .  ProductDomain((d1,d2))  represents the product of two domains, the set  {(x,y) : x \u2208 d1   y \u2208 d2} .  Multiplication of domains is overrident to return a  ProductDomain . For example, the following represents the rectangle  1 \u2264\u00a0x \u2264\u00a02   3 \u2264\u00a0y \u2264\u00a04 :  Interval(1,2)*(3,4)  source  #  ApproxFun.Ray     Type .  Ray{a}(c,o)  represents a ray at angle  a  starting at  c , with orientation out to infinity ( o = true ) or back from infinity ( o = false ).  source  #  ApproxFun.UnionDomain     Type .  UnionDomain((d1,d2,\u2026,dn))  represents a union of multiple subdomains:  {x : x \u2208 d1 || \u2026 || x \u2208 dn} .  source  #  ApproxFun.\u2202     Function .  \u2202(domain)  returns the boundary of  domain .  For example, the boundary of a  Disk()  is a  Circle() , and the boundary of  Interval()^2  is a piecewise interval that sketches the boundary of a rectangle.  source", 
            "title": "Domains"
        }, 
        {
            "location": "/#constructing-a-fun", 
            "text": "#  ApproxFun.Fun     Type .  Fun(coefficients,space)  returns a Fun with coefficients in the space  source", 
            "title": "Constructing a Fun"
        }, 
        {
            "location": "/#accessing-information-about-a-fun", 
            "text": "#  ApproxFun.domain     Function .  domain(::Fun)  returns the domain that a  Fun  is defined on  source  #  ApproxFun.coefficients     Function .  coefficients(fun,space)  returns the coefficients of a fun in a possibly different space  source  #  ApproxFun.extrapolate     Function .  extrapolate(fun,x)  returns an extrapolation of  fun  from its domain to  x .  source  #  ApproxFun.ncoefficients     Function .  ncoefficients(fun) -  Integer  returns the number of coefficients of a fun  source  #  ApproxFun.points     Function .  points(fun)  returns a grid of points that the fun can be transformed into values and back  source  #  ApproxFun.space     Function .  space(fun)  returns the space of  fun  source  #  Base.values     Function .  values(collection)  Return an iterator over all values in a collection.  collect(values(d))  returns an array of values.  source", 
            "title": "Accessing information about a Fun"
        }, 
        {
            "location": "/#modify-a-fun", 
            "text": "#  ApproxFun.reverseorientation     Function .  reverseorientation(fun)  return  fun  on a reversed orientated contour  source  #  ApproxFun.setdomain     Function .  setdomain(fun,domain)  returns  fun  projected onto  domain  source  #  Base.chop     Function .  chop(string)  Remove the last character from a string.  source", 
            "title": "Modify a Fun"
        }, 
        {
            "location": "/#operators", 
            "text": "#  ApproxFun.Operator     Type .  Operator{T}  is an abstract type to represent linear operators between spaces.  source  #  ApproxFun.linsolve     Function .  linsolve(A,b;tolerance=tol,maxlength=n)  solves a linear equation, usually differential equation, where  A  is an operator or array of operators and  b  is a  Fun  or array of funs.  The result  u  will approximately satisfy  A*u = b .  source  #  Base.LinAlg.qrfact     Method .  qrfact(A::Operator)  returns a cached QR factorization of the Operator  A .  The result  QR  enables solving of linear equations: if  u=QR\\b , then  u  approximately satisfies  A*u = b .  source  #  ApproxFun.cache     Method .  cache(operator)  Caches the entries of an operator, to speed up multiplying a Fun by the operator.  source", 
            "title": "Operators"
        }, 
        {
            "location": "/faq/", 
            "text": "Frequently Asked Questions\n\n\n\n\nApproximating functions\n\n\n\n\nHow do I interpolate a function at a specified grid?\n\n\nIn the case where the grid is specified by \npoints(space,n)\n, you can apply the default transform to data:\n\n\nS = Chebyshev([1,2])  \np = points(S,20) # the default grid\nv = exp.(p)      # values at the default grid\nf = Fun(ApproxFun.transform(S,vals),S)\n\n\n\n\nApproxFun has no inbuilt support for interpolating functions at other sets of points, but this can be accomplished manually by evaluating the basis at the set of points and using \\:\n\n\nS = Chebyshev([1,2])  \nn = 50\np = linspace(1,2,n)  # a non-default grid\nv = exp.(p)           # values at the non-default grid\n# Create a Vandermonde matrix by evaluating the basis at the grid\nV = Array(Float64,n,n)\nfor k = 1:n\n    V[:,k] = Fun([zeros(k-1);1],S)(p)\nend\nf = Fun(V\\v,S)   \n\n\n\n\nNote that an evenly spaced grid suffers from instability for large \nn\n.  The easiest way around this is to use least squares with more points than coefficients, instead of interpolation:\n\n\nS = Chebyshev([1,2])  \nn = 100; m = 50\np = linspace(1,2,n)  # a non-default grid\nv = exp.(p)           # values at the non-default grid\n# Create a Vandermonde matrix by evaluating the basis at the grid\nV = Array(Float64,n,m)\nfor k = 1:m\n    V[:,k] = Fun([zeros(k-1);1],S)(p)\nend\nf = Fun(V\\v,S)", 
            "title": "FAQ"
        }, 
        {
            "location": "/faq/#frequently-asked-questions", 
            "text": "", 
            "title": "Frequently Asked Questions"
        }, 
        {
            "location": "/faq/#approximating-functions", 
            "text": "", 
            "title": "Approximating functions"
        }, 
        {
            "location": "/faq/#how-do-i-interpolate-a-function-at-a-specified-grid", 
            "text": "In the case where the grid is specified by  points(space,n) , you can apply the default transform to data:  S = Chebyshev([1,2])  \np = points(S,20) # the default grid\nv = exp.(p)      # values at the default grid\nf = Fun(ApproxFun.transform(S,vals),S)  ApproxFun has no inbuilt support for interpolating functions at other sets of points, but this can be accomplished manually by evaluating the basis at the set of points and using \\:  S = Chebyshev([1,2])  \nn = 50\np = linspace(1,2,n)  # a non-default grid\nv = exp.(p)           # values at the non-default grid\n# Create a Vandermonde matrix by evaluating the basis at the grid\nV = Array(Float64,n,n)\nfor k = 1:n\n    V[:,k] = Fun([zeros(k-1);1],S)(p)\nend\nf = Fun(V\\v,S)     Note that an evenly spaced grid suffers from instability for large  n .  The easiest way around this is to use least squares with more points than coefficients, instead of interpolation:  S = Chebyshev([1,2])  \nn = 100; m = 50\np = linspace(1,2,n)  # a non-default grid\nv = exp.(p)           # values at the non-default grid\n# Create a Vandermonde matrix by evaluating the basis at the grid\nV = Array(Float64,n,m)\nfor k = 1:m\n    V[:,k] = Fun([zeros(k-1);1],S)(p)\nend\nf = Fun(V\\v,S)", 
            "title": "How do I interpolate a function at a specified grid?"
        }
    ]
}